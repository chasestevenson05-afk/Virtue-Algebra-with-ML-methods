import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from itertools import combinations

torch.manual_seed(42)


# -----------------------------
# Enhanced Virtue Algebra Framework
# -----------------------------

class VirtueAlgebra:
    """
    Implements algebraic operations on virtue space
    """

    def __init__(self, dimension_names):
        self.dimension_names = dimension_names
        self.virtue_names = dimension_names[3:]  # Assume first 3 are sensory

    def virtue_addition(self, v1, v2, strength=1.0):
        """Virtue addition with interaction effects"""
        result = v1 + strength * v2
        # Add nonlinear interaction term
        interaction = 0.1 * torch.tanh(v1 * v2)
        return torch.clamp(result + interaction, 0, 1)

    def virtue_multiplication(self, v1, v2):
        """Virtue multiplication (reinforcement)"""
        return torch.sqrt(v1 * v2)  # Geometric mean for balance

    def virtue_negation(self, v, strength=1.0):
        """Virtue negation (opposition)"""
        return torch.clamp(1 - strength * v, 0, 1)

    def compute_virtue_field(self, virtue_state):
        """Compute the 'field' generated by current virtue configuration"""
        virtue_dims = virtue_state[:, 3:]  # Extract virtue dimensions

        # Field strength based on virtue magnitudes
        field_strength = torch.norm(virtue_dims, dim=1, keepdim=True)

        # Field direction based on virtue balance
        field_direction = F.normalize(virtue_dims, dim=1)

        return field_strength, field_direction


class AdvancedVirtueOperator(nn.Module):
    """
    Enhanced virtue operator with algebraic structure
    """

    def __init__(self, input_dim, virtue_index, hidden_dim=32):
        super().__init__()
        self.virtue_index = virtue_index
        self.input_dim = input_dim

        # Network for computing virtue transformation
        self.transformation_net = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, input_dim)
        )

        # Network for computing interaction strengths
        self.interaction_net = nn.Sequential(
            nn.Linear(input_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, input_dim),
            nn.Sigmoid()
        )

    def forward(self, x):
        # Compute transformation
        transformation = 0.1 * torch.tanh(self.transformation_net(x))

        # Compute interaction strengths
        interaction_weights = self.interaction_net(x)

        # Apply weighted transformation
        weighted_transformation = transformation * interaction_weights

        return torch.clamp(x + weighted_transformation, 0, 1)


class HierarchicalVirtueChain(nn.Module):
    """
    Hierarchical virtue processing with multiple levels
    """

    def __init__(self, input_dim, virtue_hierarchy):
        super().__init__()
        self.virtue_hierarchy = virtue_hierarchy

        # Create operators for each level
        self.level_operators = nn.ModuleDict()
        for level, virtues in virtue_hierarchy.items():
            self.level_operators[level] = nn.ModuleList([
                AdvancedVirtueOperator(input_dim, v_idx)
                for v_idx in virtues
            ])

    def forward(self, x):
        # Process through hierarchy levels
        for level in sorted(self.virtue_hierarchy.keys()):
            for operator in self.level_operators[level]:
                x = operator(x)
        return x


class VirtueField(nn.Module):
    """
    Models virtue space as a field with potential and dynamics
    """

    def __init__(self, input_dim):
        super().__init__()
        self.input_dim = input_dim

        # Network to compute potential energy
        self.potential_net = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )

        # Network to compute force field
        self.force_net = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, input_dim)
        )

    def forward(self, x, dt=0.1):
        # Compute potential energy
        potential = self.potential_net(x)

        # Compute force field (negative gradient of potential)
        force = -self.force_net(x)

        # Update position based on force
        x_new = x + dt * force

        return torch.clamp(x_new, 0, 1), potential


# -----------------------------
# Advanced Experimental Framework
# -----------------------------

def generate_complex_virtue_data(batch_size, dim, relationships):
    """
    Generate data with complex virtue relationships
    """
    x = torch.rand(batch_size, dim)
    y = x.clone()

    for rel in relationships:
        source_idx, target_idx, strength, rel_type = rel

        if rel_type == 'cooperation':
            y[:, target_idx] = torch.clamp(
                y[:, target_idx] + strength * y[:, source_idx], 0, 1
            )
        elif rel_type == 'trade_off':
            y[:, target_idx] = torch.clamp(
                y[:, target_idx] - strength * y[:, source_idx], 0, 1
            )
        elif rel_type == 'reinforcement':
            y[:, target_idx] = torch.clamp(
                y[:, target_idx] * (1 + strength * y[:, source_idx]), 0, 1
            )

    return x, y


def analyze_virtue_manifold(model, test_data, virtue_indices):
    """
    Analyze the learned virtue manifold structure
    """
    with torch.no_grad():
        outputs = model(test_data)
        virtue_outputs = outputs[:, virtue_indices]

        # Compute pairwise distances
        distances = torch.cdist(virtue_outputs, virtue_outputs)

        # Compute manifold curvature (simplified)
        mean_distance = distances.mean()
        std_distance = distances.std()

        return {
            'virtue_outputs': virtue_outputs,
            'distances': distances,
            'mean_distance': mean_distance.item(),
            'std_distance': std_distance.item()
        }


def test_virtue_invariances(model, test_data):
    """
    Test whether virtue relationships are invariant under transformations
    """
    with torch.no_grad():
        original_output = model(test_data)

        # Test translation invariance in sensory space
        translated_data = test_data.clone()
        translated_data[:, :3] += 0.1  # Translate sensory dimensions
        translated_output = model(torch.clamp(translated_data, 0, 1))

        # Measure difference in virtue space only
        virtue_difference = torch.norm(
            original_output[:, 3:] - translated_output[:, 3:], dim=1
        ).mean()

        return virtue_difference.item()


# -----------------------------
# Enhanced Experimental Setup
# -----------------------------

def run_enhanced_experiments():
    """
    Run comprehensive experiments on virtue algebra
    """
    print("=" * 60)
    print("ENHANCED VIRTUE ALGEBRA EXPERIMENTS")
    print("=" * 60)

    PERCEPTION_DIM = 7
    BATCH_SIZE = 200
    dimension_names = ['Visual', 'Auditory', 'Tactile', 'Compassion', 'Justice', 'Honesty', 'Generosity']

    # Define complex virtue relationships
    relationships = [
        (3, 4, 0.3, 'trade_off'),  # Compassion-Justice trade-off
        (5, 6, 0.4, 'cooperation'),  # Honesty-Generosity cooperation
        (3, 5, 0.2, 'reinforcement'),  # Compassion reinforces Honesty
        (4, 6, 0.15, 'trade_off'),  # Justice trades off with Generosity
    ]

    # Generate complex training data
    perceptions, targets = generate_complex_virtue_data(
        BATCH_SIZE, PERCEPTION_DIM, relationships
    )

    # Define virtue hierarchy
    virtue_hierarchy = {
        'primary': [3, 4],  # Compassion, Justice (fundamental)
        'secondary': [5, 6]  # Honesty, Generosity (derived)
    }

    # Create advanced model
    model = HierarchicalVirtueChain(PERCEPTION_DIM, virtue_hierarchy)
    criterion = nn.MSELoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=0.005)

    # Training loop
    print("Training hierarchical virtue model...")
    for epoch in range(300):
        optimizer.zero_grad()
        output = model(perceptions)
        loss = criterion(output, targets)
        loss.backward()
        optimizer.step()

        if (epoch + 1) % 50 == 0:
            print(f"Epoch {epoch + 1}, Loss: {loss.item():.6f}")

    # Analysis
    print("\n=== Advanced Analysis ===")

    # 1. Virtue manifold analysis
    manifold_analysis = analyze_virtue_manifold(model, perceptions, [3, 4, 5, 6])
    print(f"Virtue manifold mean distance: {manifold_analysis['mean_distance']:.4f}")
    print(f"Virtue manifold std distance: {manifold_analysis['std_distance']:.4f}")

    # 2. Test invariances
    invariance_score = test_virtue_invariances(model, perceptions)
    print(f"Sensory-virtue invariance score: {invariance_score:.6f}")
    print("(Lower scores indicate better invariance)")

    # 3. Analyze learned correlations
    with torch.no_grad():
        outputs = model(perceptions)
        virtue_outputs = outputs[:, 3:]
        correlations = torch.corrcoef(virtue_outputs.T).numpy()

    print(f"\nLearned virtue correlations:")
    print(f"Compassion-Justice: {correlations[0, 1]:.4f} (expected: negative)")
    print(f"Honesty-Generosity: {correlations[2, 3]:.4f} (expected: positive)")
    print(f"Compassion-Honesty: {correlations[0, 2]:.4f} (expected: positive)")
    print(f"Justice-Generosity: {correlations[1, 3]:.4f} (expected: negative)")

    return model, manifold_analysis, correlations


# Run the enhanced experiments
if __name__ == "__main__":
    model, manifold_analysis, correlations = run_enhanced_experiments()
    print("\n" + "=" * 60)
    print("EXPERIMENT COMPLETE - Revolutionary virtue algebra demonstrated!")
    print("=" * 60)
